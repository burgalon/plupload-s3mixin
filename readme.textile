h1. Plupload S3 mixin for Django

Use this together with Plupload to upload files into your S3

h2. Dependencies

django-mediagenerator - https://bitbucket.org/wkornewald/django-mediagenerator/src - this can be easily altered to suit your needs
djangotoolbox - https://bitbucket.org/wkornewald/djangotoolbox - for JSONResponse. This can be easily altered if you don't want to install djangotoolbox
appengine-urlfetch - This was built for use in AppEngine however can be easily changed to use urllib


h2. Signals

S3policy sends 's3policy_request' signal to allow your application to check for permissions for the upload. So for example, you could do add:
<code>
def s3policy_request_callback(sender, prefix, **kwargs):
	if not request.user.is_admin():
		raise ValueError('You do not have permission to upload here.')

s3mixin.s3policy_request.connect(s3policy_request_callback)
</code>

h2. Installation

# Change your model to inherit from s3mixin.models.S3Mixin instead of django.Model

# Add in your urls.py in 'urlpatterns' array:
<code>url(r'^model_name/(?P<prefix>[^\.^/]+)/s3policy/$', 's3mixin.s3policy', {}, name='s3policy' ),</code>
Prefix is a foreign key to which the file belongs to.
Prefix parameter will be added to the upload path. You might want to wrap s3policy with your own s3policy in order to validate prefix and permissions, and then if everything is right, call the original s3policy. For example:
<code>
@login_required
def s3policy(request, prefix):
    if int(prefix) != request.user.id:
        return HttpResponseBadRequest('prefix must match the user id')
    return s3mixin.views.s3policy(request, prefix)
</code>
Example prefix might be a blog/forum id that the user has permission to.
A simplistic prefix might be the user-id to which the file will be linked to.
You may use the GET['file_size'] to create a more robust logic for upload size limits.

# In your form, use S3FileWidget

# In your template, make sure to include
<code>
<script type="text/javascript" src="{% media_url 'js/plupload/plupload.full.min.js' %}"></script>
<script type="text/javascript" src="{% media_url 'plupload-s3.js' %}"></script>
<script type="text/javascript">
    {{ profile_form.fields.file.widget.javascript }}
</script>
</code>

# In your settings.py add:
<code>
AWS_ACCESS_KEY_ID = ''
AWS_SECRET_ACCESS_KEY = ''
AWS_MAX_FILE_SIZE = '10MB'
AWS_BUCKET = 'dev-bucket' if not on_production_server else 'prod-bucket'
AWS_PREFIX = 'http://%s.s3.amazonaws.com/' % (AWS_BUCKET)
AWS_CLOUDFRONT = 'http://%s.my-cloudfront.com/' % AWS_BUCKET # Your CNAME for Cloudfront
</code>

# Add crossdomain.xml to your AWS_BUCKET of the sort:
<cross-domain-policy>
    <allow-access-from domain="*" secure="false"/>
</cross-domain-policy>

Finally, when you think all setup is done, run the page through a browser, make sure that the widget's javascript is rendering, and that nothing fails on the javascript
h2. Comments

# Notice that the code has <code>resize : {width : 1920, height : 1080, quality : 90}</code> which means that all uploaded JPG/PNG will be resized if larger than 1920x1080. This seems reasonable with our current global standards.
# S3Mixin has SERVER_TYPES attribute which allows setting file types which you might want to store on the server side (to allow reading the file directly from DB and not through S3). Currently it's set to HTML files. You might want to change this.
# Currently only the Flash runtime of Plupload is being used in order to keep things consistent and stable. S3 requires cross-domain upload and passing multi-part consistently in order to match the signature. Some of the runtimes are not passing the same parameters exactly as the Flash runtime and might require some tweaking in order to work.
# Files are uploaded with some 'id' prefix which you should provide to S3FileWidget (for example, the parent model id) and a timestamp for cache busting. S3 uploads
# Feel free to fork and help to turn this into a pluggable app which is generic enough